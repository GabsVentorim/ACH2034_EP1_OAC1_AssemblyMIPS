#define N 4
#define M 4

.data
    X:  .word  1, 2, 3, 4,
         5, 6, 7, 8,
         9, 10, 11, 12,
         13, 14, 15, 16
    
.text
.globl main
main:
    # Alocando espaço para a matriz transposta
    li $t0, N
    li $t1, M
    mul $t0, $t0, $t1   # Calculando o tamanho total da matriz
    sll $t0, $t0, 2     # Multiplicando por 4 para obter o deslocamento em bytes
    li $v0, 9          # Código de chamada do sistema para alocar memória
    syscall            # Alocando espaço na memória para a matriz transposta
    move $t2, $v0      # Armazenando o endereço da matriz transposta em $t2

    # Calculando a transposta
    la $t3, X          # Carregando o endereço base da matriz original
    
    li $t4, 0          # Índice da linha atual
    
outer_loop:
    beq $t4, $t0, exit_outer_loop  # Se t4 = N, sair do loop externo
    
    li $t5, 0          # Índice da coluna atual
    
inner_loop:
    beq $t5, $t1, exit_inner_loop  # Se t5 = M, sair do loop interno
    
    # Calculando os endereços dos elementos na matriz original e transposta
    mul $t6, $t4, $t1    # t6 = t4 * M
    add $t7, $t6, $t5    # t7 = t6 + t5
    
    mul $t8, $t5, $t0    # t8 = t5 * N
    add $t8, $t8, $t4    # t8 = t8 + t4
    
    sll $t6, $t6, 2      # t6 = t6 * 4
    sll $t8, $t8, 2      # t8 = t8 * 4
    
    add $t6, $t6, $t3    # Endereço do elemento na matriz original
    add $t8, $t8, $t2    # Endereço do elemento na matriz transposta
    
    lw $t6, 0($t6)       # Carregar o elemento da matriz original
    sw $t6, 0($t8)       # Armazenar o elemento na matriz transposta
    
    addi $t5, $t5, 1     # Incrementar o índice da coluna
    j inner_loop         # Voltar ao início do loop interno
    
exit_inner_loop:
    addi $t4, $t4, 1     # Incrementar o índice da linha
    j outer_loop         # Voltar ao início do loop externo
    
exit_outer_loop:
    # Retornar o endereço da matriz transposta
    move $v0, $t2

    # Fim do programa
    li $v0, 
